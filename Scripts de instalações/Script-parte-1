#!/bin/bash

# ============================================================================
# üöÄ KRYONIX - SCRIPT PARTE 01 -
# CONFIGURA√á√ÉO KEYCLOAK DOCKER SWARM 
# ============================================================================
# 
# Desenvolvido por: Vitor Jayme Fernandes Ferreira
# Data: Agosto 2025
# 
# VERS√ÉO CORRIGIDA: Resolve todos os problemas de autentica√ß√£o PostgreSQL
# - ‚úÖ Corrigido: Usu√°rio -U kryonix -> -U postgres
# - ‚úÖ Corrigido: Suporte completo ao Supabase PostgreSQL
# - ‚úÖ Corrigido: String de conex√£o Keycloak
# - ‚úÖ Corrigido: Deploy Docker Swarm com configura√ß√µes corretas
# - ‚úÖ Adicionado: Detec√ß√£o autom√°tica PostgreSQL vs Supabase
# - ‚úÖ Adicionado: Monitoramento e backup para ambos os tipos
#
# Este script deve ser executado NO SEU SERVIDOR ap√≥s o pull da main
# Ele configura tudo que n√£o vem automaticamente com o c√≥digo
#
# Uso: bash Script-parte-1
# 
# VERS√ÉO: Corrigida com funcionalidades avan√ßadas de monitoramento,
# backup autom√°tico e sistema de notifica√ß√µes WhatsApp integrado
# ============================================================================

# Configura√ß√µes de seguran√ßa
set -euo pipefail
export LC_ALL=C.UTF-8 2>/dev/null || export LC_ALL=C
export LANG=C.UTF-8 2>/dev/null || export LANG=C

# ============================================================================
# CRIA√á√ÉO IMEDIATA DOS DIRET√ìRIOS NECESS√ÅRIOS
# ============================================================================
# IMPORTANTE: Criar diret√≥rios ANTES de qualquer fun√ß√£o de log
readonly LOG_DIR="/opt/kryonix/logs"
readonly CONFIG_DIR="/opt/kryonix/config"
readonly SCRIPTS_DIR="/opt/kryonix/scripts"
readonly BACKUP_DIR="/opt/kryonix/backups"
readonly CLIENTS_DIR="/opt/kryonix/clients"

# Criar todos os diret√≥rios necess√°rios IMEDIATAMENTE
mkdir -p "$LOG_DIR" "$CONFIG_DIR" "$SCRIPTS_DIR" "$BACKUP_DIR" "$CLIENTS_DIR"
mkdir -p /etc/traefik/dynamic

# ============================================================================
# CONFIGURA√á√ïES GLOBAIS - CREDENCIAIS REAIS DO PROJETO
# ============================================================================

# Servidor e dom√≠nios
readonly SERVER_IP="${SERVER_IP:-45.76.246.44}"
readonly DOMAIN_BASE="kryonix.com.br"
readonly PROJECT_NAME="KRYONIX"

# Credenciais de autentica√ß√£o
readonly KEYCLOAK_ADMIN_USER="kryonix"
readonly KEYCLOAK_ADMIN_PASSWORD="${KEYCLOAK_ADMIN_PASSWORD:-Vitor@123456}"
readonly POSTGRES_PASSWORD="${POSTGRES_PASSWORD:-Vitor@123456}"

# Credenciais APIs
readonly EVOLUTION_API_KEY="${EVOLUTION_API_KEY:-2f4d6967043b87b5ebee57b872e0223a}"
readonly EVOLUTION_API_URL="https://api.kryonix.com.br"
readonly JWT_SECRET="Kr7\$n0x-V1t0r-2025-#Jwt\$3cr3t-P0w3rfu1-K3y-A9b2Cd8eF4g6H1j5K9m3N7p2Q5t8"

# Comunica√ß√£o e notifica√ß√µes
readonly WHATSAPP_ALERT="${WHATSAPP_ALERT:-+5517981805327}"
readonly ADMIN_EMAIL="vitor.nakahh@gmail.com"

# GitHub e CI/CD
readonly GITHUB_REPO="https://github.com/Nakahh/KRYONIX-PLATAFORMA.git"
readonly PAT_TOKEN="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"
readonly WEBHOOK_URL="https://kryonix.com.br/api/github-webhook"
readonly WEBHOOK_SECRET="Kr7\$n0x-V1t0r-2025-#Jwt\$3cr3t-P0w3rfu1-K3y-A9b2Cd8eF4g6H1j5K9m3N7p2Q5t8"

# SendGrid para emails
readonly SENDGRID_API_KEY="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"

# ============================================================================
# CORES E FORMATA√á√ÉO
# ============================================================================
readonly RED='\033[0;31m'
readonly GREEN='\033[0;32m'
readonly YELLOW='\033[1;33m'
readonly BLUE='\033[0;34m'
readonly PURPLE='\033[0;35m'
readonly CYAN='\033[0;36m'
readonly WHITE='\033[1;37m'
readonly BOLD='\033[1m'
readonly NC='\033[0m'

# Emojis seguros para ASCII
readonly CHECK="‚úÖ"
readonly CROSS="‚ùå"
readonly WARNING="‚ö†Ô∏è"
readonly ROCKET="üöÄ"
readonly GEAR="‚öôÔ∏è"
readonly LOCK="üîê"

# ============================================================================
# SISTEMA DE LOGGING E CONTROLE
# ============================================================================

# Diret√≥rios e arquivos
readonly LOCK_FILE="/tmp/kryonix-parte01-$(date +%Y%m%d).lock"
readonly LOG_FILE="$LOG_DIR/parte01-$(date +%Y%m%d_%H%M%S).log"

# Contador de progresso
CURRENT_STEP=0
readonly TOTAL_STEPS=20

# Fun√ß√£o de logging centralizada
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local color=""
    local prefix=""
    
    case "$level" in
        "INFO")
            color="$GREEN"
            prefix="[INFO]"
            ;;
        "WARN")
            color="$YELLOW"
            prefix="[WARN]"
            ;;
        "ERROR")
            color="$RED"
            prefix="[ERROR]"
            ;;
        "DEBUG")
            color="$BLUE"
            prefix="[DEBUG]"
            ;;
        "STEP")
            color="$PURPLE"
            prefix="[STEP]"
            CURRENT_STEP=$((CURRENT_STEP + 1))
            ;;
    esac
    
    echo -e "${color}[$timestamp] $prefix${NC} $message" | tee -a "$LOG_FILE"
}

# Fun√ß√µes de logging especializadas
log_info() { log "INFO" "$1"; }
log_warn() { log "WARN" "$1"; }
log_error() { log "ERROR" "$1"; }
log_debug() { log "DEBUG" "$1"; }
log_step() { log "STEP" "$CHECK Etapa $CURRENT_STEP/$TOTAL_STEPS: $1"; }

# ============================================================================
# SISTEMA DE CONTROLE E SEGURAN√áA
# ============================================================================

# Fun√ß√£o de cleanup
cleanup() {
    log_info "Executando cleanup..."
    rm -f "$LOCK_FILE"
    log_info "Script finalizado em $(date)"
}

# Fun√ß√£o de tratamento de erro
error_exit() {
    local line_number="$1"
    local error_code="$2"
    log_error "Erro na linha $line_number com c√≥digo $error_code"
    log_error "Consultando logs em: $LOG_FILE"
    
    # Enviar notifica√ß√£o de erro via WhatsApp se Evolution API estiver dispon√≠vel
    send_whatsapp_notification "‚ùå ERRO no script KRYONIX PARTE-01 - Linha: $line_number - Verificar logs: $LOG_FILE" || true
    
    exit "$error_code"
}

# Configurar traps
trap cleanup EXIT INT TERM
trap 'error_exit ${LINENO} $?' ERR

# ============================================================================
# FUN√á√ïES DE VALIDA√á√ÉO
# ============================================================================

# Verificar se j√° est√° rodando
check_already_running() {
    if [ -f "$LOCK_FILE" ]; then
        local pid=$(cat "$LOCK_FILE" 2>/dev/null || echo "")
        if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
            log_error "Script j√° est√° sendo executado (PID: $pid)"
            log_error "Se tiver certeza que n√£o est√° rodando, remova: $LOCK_FILE"
            exit 1
        else
            log_warn "Lock file √≥rf√£o encontrado, removendo..."
            rm -f "$LOCK_FILE"
        fi
    fi
    
    # Criar lock file
    echo $$ > "$LOCK_FILE"
    log_info "Lock file criado com PID: $$"
}

# Verificar permiss√µes de root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "Este script deve ser executado como root"
        log_error "Execute: sudo bash $0"
        exit 1
    fi
    log_info "Permiss√µes de root verificadas"
}

# Verificar depend√™ncias do sistema
check_system_dependencies() {
    log_step "Verificando depend√™ncias do sistema"
    
    local missing_deps=()
    local required_deps=("docker" "python3" "curl" "jq" "cron")
    
    for dep in "${required_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            missing_deps+=("$dep")
        else
            log_info "$CHECK $dep est√° dispon√≠vel"
        fi
    done
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        log_error "Depend√™ncias faltando: ${missing_deps[*]}"
        log_info "Instalando depend√™ncias automaticamente..."
        
        # Detectar distribui√ß√£o e instalar
        if command -v apt-get &> /dev/null; then
            apt-get update && apt-get install -y "${missing_deps[@]}" jq
        elif command -v yum &> /dev/null; then
            yum install -y "${missing_deps[@]}" jq
        else
            log_error "Gerenciador de pacotes n√£o suportado"
            exit 1
        fi
    fi
    
    log_info "$CHECK Todas as depend√™ncias est√£o disponÔøΩÔøΩveis"
}

# Verificar Docker Swarm
check_docker_swarm() {
    log_step "Verificando Docker Swarm"

    if ! docker info | grep -q "Swarm: active"; then
        log_warn "Docker Swarm n√£o est√° ativo! Tentando reativar..."

        # Tentar deixar swarm primeiro (limpar estado)
        docker swarm leave --force 2>/dev/null || true
        sleep 5

        # Reinicializar swarm
        if docker swarm init --advertise-addr $(hostname -I | awk '{print $1}') 2>/dev/null; then
            log_info "‚úÖ Docker Swarm inicializado com IP espec√≠fico"
        elif docker swarm init 2>/dev/null; then
            log_info "‚úÖ Docker Swarm inicializado (fallback)"
        else
            log_error "‚ùå Falha cr√≠tica ao ativar Docker Swarm"
            log_error "Execute manualmente: docker swarm init"
            exit 1
        fi

        sleep 10

        # Verificar se rede existe
        if ! docker network ls | grep -q "Kryonix-NET"; then
            docker network create -d overlay --attachable Kryonix-NET 2>/dev/null || true
            log_info "ÔøΩÔøΩÔøΩ Rede Kryonix-NET recriada"
        fi
    fi

    log_info "$CHECK Docker Swarm est√° ativo"
}

# Verificar espa√ßo em disco
check_disk_space() {
    log_step "Verificando espa√ßo em disco"
    
    local disk_available=$(df / | awk 'NR==2 {print $4}')
    local required_space=5242880  # 5GB em KB
    
    if [ "$disk_available" -lt "$required_space" ]; then
        log_error "Espa√ßo em disco insuficiente!"
        log_error "Dispon√≠vel: $(($disk_available / 1024 / 1024))GB"
        log_error "Necess√°rio: 5GB"
        exit 1
    fi
    
    log_info "$CHECK Espa√ßo em disco suficiente: $(($disk_available / 1024 / 1024))GB dispon√≠vel"
}

# ============================================================================
# FUN√á√ïES DE REDE E CONECTIVIDADE
# ============================================================================

# Verificar rede Docker
check_docker_network() {
    log_step "Verificando/criando rede Docker"
    
    local network_name="Kryonix-NET"
    
    if docker network ls --format "{{.Name}}" | grep -q "^${network_name}$"; then
        log_info "$CHECK Rede $network_name j√° existe"
    else
        log_info "Criando rede $network_name..."
        docker network create -d overlay --attachable "$network_name"
        log_info "$CHECK Rede $network_name criada"
    fi
}

# Verificar conectividade externa
check_external_connectivity() {
    log_step "Verificando conectividade externa"
    
    local test_urls=(
        "https://api.github.com"
        "https://registry-1.docker.io"
        "https://$DOMAIN_BASE"
    )
    
    for url in "${test_urls[@]}"; do
        if curl -f -s --max-time 10 "$url" > /dev/null 2>&1; then
            log_info "$CHECK Conectividade com $url OK"
        else
            log_warn "$WARNING Problema de conectividade com $url"
        fi
    done
}

# ============================================================================
# FUN√á√ïES DE SERVI√áOS BASE
# ============================================================================

# Verificar servi√ßos base necess√°rios
check_base_services() {
    log_step "Verificando servi√ßos base necess√°rios"

    # Verificar PostgreSQL - pode ser postgresql-kryonix ou Supabase
    log_info "Verificando PostgreSQL..."
    if docker ps --format "{{.Names}}" | grep -q "^postgresql-kryonix$"; then
        log_info "$CHECK postgresql-kryonix est√° rodando"
        export POSTGRES_CONTAINER="postgresql-kryonix"
        export POSTGRES_HOST="postgresql-kryonix"
        export POSTGRES_PORT="5432"
        export POSTGRES_USER="postgres"
    elif docker ps --format "{{.Names}}" | grep -q "supabase_db"; then
        POSTGRES_CONTAINER=$(docker ps --format "{{.Names}}" | grep "supabase_db" | head -1)
        log_info "$CHECK Supabase PostgreSQL est√° rodando: $POSTGRES_CONTAINER"
        export POSTGRES_CONTAINER="$POSTGRES_CONTAINER"
        export POSTGRES_HOST="supabase.kryonix.com.br"
        export POSTGRES_PORT="5432"
        export POSTGRES_USER="postgres"
    elif curl -f -s --max-time 5 "https://supabase.kryonix.com.br" > /dev/null 2>&1; then
        log_info "$CHECK Supabase externo est√° acess√≠vel"
        export POSTGRES_CONTAINER="external-supabase"
        export POSTGRES_HOST="supabase.kryonix.com.br"
        export POSTGRES_PORT="5432"
        export POSTGRES_USER="postgres"
    else
        log_error "Nenhum PostgreSQL encontrado!"
        log_error "Containers dispon√≠veis:"
        docker ps --format "{{.Names}}" | head -10 | while read container; do
            log_error "- $container"
        done
        exit 1
    fi

    # Verificar Traefik (opcional)
    log_info "Verificando Traefik..."
    if docker ps --format "table {{.Names}}" | grep -q "traefik"; then
        log_info "$CHECK Traefik est√° rodando"
    else
        log_warn "‚ö†ÔøΩÔøΩ Traefik n√£o encontrado - proxy manual ser√° necess√°rio"
    fi
}

# ============================================================================
# CONFIGURA√á√ÉO DO KEYCLOAK
# ============================================================================

# Verificar e corrigir banco de dados Keycloak
check_and_fix_keycloak_database() {
    log_step "Verificando e corrigindo banco de dados Keycloak"
    
    log_info "Testando conectividade com PostgreSQL..."
    
    # Tentar diferentes m√©todos de conex√£o baseado no tipo de PostgreSQL
    if [ "$POSTGRES_CONTAINER" = "external-supabase" ]; then
        # Supabase externo - usar psql direto
        log_info "Conectando ao Supabase externo..."
        
        # Verificar se database keycloak existe
        if ! PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U postgres -d postgres -lqt 2>/dev/null | cut -d \| -f 1 | grep -qw keycloak; then
            log_info "Criando database keycloak no Supabase..."
            PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U postgres -d postgres -c "CREATE DATABASE keycloak WITH ENCODING 'UTF8' LC_COLLATE = 'C' LC_CTYPE = 'C' TEMPLATE template0;" 2>/dev/null || {
                log_warn "Falha com postgres, tentando com kryonix..."
                PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U kryonix -d postgres -c "CREATE DATABASE keycloak WITH ENCODING 'UTF8' LC_COLLATE = 'C' LC_CTYPE = 'C' TEMPLATE template0;" 2>/dev/null || true
            }
        fi
        
        # Verificar se usu√°rio keycloak_user existe
        if ! PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U postgres -d postgres -t -c "SELECT 1 FROM pg_roles WHERE rolname='keycloak_user'" 2>/dev/null | grep -q 1; then
            log_info "Criando usu√°rio keycloak_user no Supabase..."
            PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U postgres -d postgres -c "CREATE USER keycloak_user WITH PASSWORD '$POSTGRES_PASSWORD';" 2>/dev/null || {
                log_warn "Falha com postgres, tentando com kryonix..."
                PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U kryonix -d postgres -c "CREATE USER keycloak_user WITH PASSWORD '$POSTGRES_PASSWORD';" 2>/dev/null || true
            }
        fi
        
        # Conceder privil√©gios
        PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U postgres -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE keycloak TO keycloak_user;" 2>/dev/null || {
            log_warn "Falha com postgres, tentando com kryonix..."
            PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U kryonix -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE keycloak TO keycloak_user;" 2>/dev/null || true
        }
        
        log_info "$CHECK Conectividade com Supabase testada"
        
    else
        # PostgreSQL local (Docker)
        log_info "Conectando ao PostgreSQL local..."
        
        # Verificar se database keycloak existe
        if ! docker exec $POSTGRES_CONTAINER psql -h 127.0.0.1 -U postgres -d postgres -lqt | cut -d \| -f 1 | grep -qw keycloak; then
            log_info "Criando database keycloak..."
            docker exec $POSTGRES_CONTAINER psql -h 127.0.0.1 -U postgres -d postgres -c "CREATE DATABASE keycloak WITH ENCODING 'UTF8' LC_COLLATE = 'C' LC_CTYPE = 'C' TEMPLATE template0;"
            log_info "$CHECK Database keycloak criado"
        else
            log_info "$CHECK Database keycloak j√° existe"
        fi

        # Verificar se usu√°rio keycloak_user existe  
        if ! docker exec $POSTGRES_CONTAINER psql -h 127.0.0.1 -U postgres -d postgres -t -c "SELECT 1 FROM pg_roles WHERE rolname='keycloak_user'" | grep -q 1; then
            log_info "Criando usu√°rio keycloak_user..."
            docker exec $POSTGRES_CONTAINER psql -h 127.0.0.1 -U postgres -d postgres -c "CREATE USER keycloak_user WITH PASSWORD '$POSTGRES_PASSWORD';"
            log_info "$CHECK Usu√°rio keycloak_user criado"
        else
            log_info "$CHECK Usu√°rio keycloak_user j√° existe"
        fi

        # Garantir privil√©gios no database
        log_info "Concedendo privil√©gios..."
        docker exec $POSTGRES_CONTAINER psql -h 127.0.0.1 -U postgres -d postgres -c "GRANT ALL PRIVILEGES ON DATABASE keycloak TO keycloak_user;"
        log_info "$CHECK Privil√©gios concedidos"
    fi
}

# Criar configura√ß√µes do Keycloak  
create_keycloak_config() {
    log_step "Criando configura√ß√µes do Keycloak"
    
    # Verificar e preparar database
    check_and_fix_keycloak_database
    
    # Criar configura√ß√£o do Docker Compose
    cat > "$CONFIG_DIR/keycloak.yml" << EOF
version: '3.8'
services:
  keycloak:
    image: quay.io/keycloak/keycloak:24.0
    container_name: keycloak-kryonix
    command: start
    environment:
      KEYCLOAK_ADMIN: "$KEYCLOAK_ADMIN_USER"
      KEYCLOAK_ADMIN_PASSWORD: "$KEYCLOAK_ADMIN_PASSWORD"
      KC_DB: "postgres"
      KC_DB_URL: "jdbc:postgresql://$POSTGRES_HOST:$POSTGRES_PORT/keycloak"
      KC_DB_USERNAME: "keycloak_user"
      KC_DB_PASSWORD: "$POSTGRES_PASSWORD"
      KC_HOSTNAME: "keycloak.$DOMAIN_BASE"
      KC_PROXY: "edge"
      KC_HTTP_ENABLED: "true"
      KC_HEALTH_ENABLED: "true"
      KC_METRICS_ENABLED: "true"
      KC_LOG_LEVEL: "INFO"
      KC_FEATURES: "preview"
      KC_DB_URL_HOST: "$POSTGRES_HOST"
      KC_DB_URL_PORT: "$POSTGRES_PORT"
      KC_DB_URL_DATABASE: "keycloak"
      KC_HOSTNAME_STRICT: "false"
      KC_HOSTNAME_STRICT_HTTPS: "false"
    labels:
      - "traefik.enable=true"
      - "traefik.http.routers.keycloak.rule=Host(\`keycloak.$DOMAIN_BASE\`)"
      - "traefik.http.routers.keycloak.tls=true"
      - "traefik.http.routers.keycloak.tls.certresolver=letsencrypt"
      - "traefik.http.services.keycloak.loadbalancer.server.port=8080"
      - "traefik.http.routers.keycloak.middlewares=secure-headers"
    networks:
      - Kryonix-NET
    extra_hosts:
      - "host.docker.internal:host-gateway"
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 3
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M
networks:
  Kryonix-NET:
    external: true
EOF
    
    log_info "$CHECK Configura√ß√£o do Keycloak criada"
}

# Limpar locks do Liquibase e problemas de database
clean_liquibase_locks() {
    log_info "üîß Limpando locks Liquibase e preparando database..."
    
    if [ "$POSTGRES_CONTAINER" != "external-supabase" ]; then
        # PostgreSQL local
        docker exec $POSTGRES_CONTAINER psql -U postgres -d keycloak -c "DELETE FROM DATABASECHANGELOGLOCK;" 2>/dev/null || true
        docker exec $POSTGRES_CONTAINER psql -U postgres -d keycloak -c "UPDATE DATABASECHANGELOGLOCK SET LOCKED=FALSE, LOCKGRANTED=null, LOCKEDBY=null where ID=1;" 2>/dev/null || true
    else
        # Supabase externo
        PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U postgres -d keycloak -c "DELETE FROM DATABASECHANGELOGLOCK;" 2>/dev/null || true
        PGPASSWORD="$POSTGRES_PASSWORD" psql -h "$POSTGRES_HOST" -U postgres -d keycloak -c "UPDATE DATABASECHANGELOGLOCK SET LOCKED=FALSE, LOCKGRANTED=null, LOCKEDBY=null where ID=1;" 2>/dev/null || true
    fi
    
    log_info "$CHECK Locks Liquibase limpos"
}

# Usar porta 8082 diretamente - SEM VERIFICA√á√ïES
setup_keycloak_port() {
    log_info "üéØ Configurando Keycloak para porta 8082 diretamente"

    # Configura√ß√£o direta - sem verifica√ß√µes
    export KEYCLOAK_PORT="8082"
    export KEYCLOAK_BASE_PORT="8082"
    export KRYONIX_WEB_WAS_RUNNING=true  # Sempre garantir que web esteja ativo

    log_info "‚úÖ Porta 8082 configurada para Keycloak"
    log_info "‚úÖ Kryonix_web ser√° mantido ativo na porta 8080"

    # Fun√ß√£o auxiliar para verificar se porta est√° ocupada
    is_port_occupied() {
        local port="$1"
        local occupied=false

        # Verificar netstat
        if command -v netstat >/dev/null 2>&1; then
            local netstat_result=""
            netstat_result=$(netstat -tlnp 2>/dev/null | grep ":$port ")
            if [ -n "$netstat_result" ]; then
                occupied=true
            fi
        fi

        # Verificar Docker services
        if [ "$occupied" = "false" ] && [ -n "$docker_services" ]; then
            if echo "$docker_services" | grep -q ":$port->"; then
                occupied=true
            fi
        fi

        # Teste direto TCP
        if [ "$occupied" = "false" ]; then
            timeout 1 bash -c "echo >/dev/tcp/localhost/$port" >/dev/null 2>&1
            if [ $? -eq 0 ]; then
                occupied=true
            fi
        fi

        [ "$occupied" = "true" ]
    }

    # J√° configurado na fun√ß√£o setup_keycloak_port - apenas confirmar
    log_info "$CHECK Keycloak configurado na porta: $KEYCLOAK_PORT (8082)"

    # Salvar porta para refer√™ncia
    echo "$KEYCLOAK_PORT" > "$CONFIG_DIR/.keycloak-port"

    return 0
}

# Fazer deploy definitivo do Keycloak
deploy_keycloak_service() {
    log_step "Fazendo deploy DEFINITIVO do Keycloak"

    # Garantir que Docker Swarm est√° ativo antes do deploy
    if ! docker info | grep -q "Swarm: active"; then
        log_warn "Docker Swarm n√£o est√° ativo! Reativando antes do deploy..."
        check_docker_swarm
    fi

    # Verificar conflitos de porta
    check_port_conflicts
    
    # Limpar locks antes do deploy
    clean_liquibase_locks
    
    # Remover servi√ßo anterior se existir
    if docker service ls --format "{{.Name}}" | grep -q "kryonix-auth_keycloak"; then
        log_info "Removendo servi√ßo Keycloak anterior..."
        docker service rm kryonix-auth_keycloak 2>/dev/null || true
        sleep 15
    fi
    
    # Detectar IP do PostgreSQL se for container local
    if [ "$POSTGRES_CONTAINER" != "external-supabase" ]; then
        POSTGRES_IP=$(docker inspect $POSTGRES_CONTAINER --format='{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' 2>/dev/null || echo "10.0.1.70")
        log_info "IP do PostgreSQL detectado: $POSTGRES_IP"
        export POSTGRES_HOST="$POSTGRES_IP"
    fi
    
    log_info "Fazendo deploy com configura√ß√£o DEFINITIVA na porta $KEYCLOAK_PORT..."
    log_info "Mapeamento: Host porta $KEYCLOAK_PORT -> Container porta 8080"

    # Criar servi√ßo Docker Swarm com labels corretas do Traefik
    docker service create \
        --name kryonix-auth_keycloak \
        --network Kryonix-NET \
        --replicas 1 \
        --constraint 'node.role==manager' \
        --publish "mode=host,target=8080,published=${KEYCLOAK_PORT}" \
        --env KEYCLOAK_ADMIN="$KEYCLOAK_ADMIN_USER" \
        --env KEYCLOAK_ADMIN_PASSWORD="$KEYCLOAK_ADMIN_PASSWORD" \
        --env KC_DB=postgres \
        --env KC_DB_URL="jdbc:postgresql://$POSTGRES_HOST:$POSTGRES_PORT/keycloak" \
        --env KC_DB_USERNAME=keycloak_user \
        --env KC_DB_PASSWORD="$POSTGRES_PASSWORD" \
        --env KC_HOSTNAME="keycloak.$DOMAIN_BASE" \
        --env KC_PROXY=edge \
        --env KC_HTTP_ENABLED=true \
        --env KC_HTTP_PORT=8080 \
        --env KC_HEALTH_ENABLED=true \
        --env KC_METRICS_ENABLED=true \
        --env KC_LOG_LEVEL=INFO \
        --env KC_FEATURES=preview \
        --env KC_HOSTNAME_STRICT=false \
        --env KC_HOSTNAME_STRICT_HTTPS=false \
        --env KC_PROXY_ADDRESS_FORWARDING=true \
        --env JAVA_OPTS="-Xms256m -Xmx512m -Djava.net.preferIPv4Stack=true" \
        --label traefik.enable=true \
        --label traefik.docker.network=Kryonix-NET \
        --label traefik.http.services.keycloak.loadbalancer.server.port=8080 \
        --label traefik.http.services.keycloak.loadbalancer.healthcheck.path=/health/ready \
        --label traefik.http.services.keycloak.loadbalancer.healthcheck.interval=15s \
        --label traefik.http.routers.keycloak.rule="Host(\`keycloak.$DOMAIN_BASE\`)" \
        --label traefik.http.routers.keycloak.entrypoints=web,websecure \
        --label traefik.http.routers.keycloak.service=keycloak \
        --label traefik.http.routers.keycloak.priority=1000 \
        --label traefik.http.routers.keycloak.tls=true \
        --label traefik.http.routers.keycloak.tls.certresolver=letsencrypt \
        --limit-memory 1g \
        --reserve-memory 512m \
        --restart-condition any \
        --restart-delay 15s \
        --restart-max-attempts 5 \
        quay.io/keycloak/keycloak:24.0 start
    
    log_info "Aguardando servi√ßo Keycloak ficar pronto (comando FUNCIONANDO)..."
    
    # Aguardar servi√ßo ficar ready
    local max_attempts=50
    local attempt=1
    
    while [ $attempt -le $max_attempts ]; do
        local replicas=$(docker service ls --filter name=kryonix-auth_keycloak --format "{{.Replicas}}" 2>/dev/null || echo "0/1")
        
        if [[ "$replicas" == "1/1" ]]; then
            # Aguardar mais um pouco para inicializa√ß√£o completa
            sleep 30
            # Testar se est√° realmente respondendo
            if curl -f -s --max-time 10 "http://localhost:$KEYCLOAK_PORT/health/ready" > /dev/null 2>&1; then
                log_info "$CHECK Servi√ßo Keycloak est√° pronto e respondendo!"
                break
            else
                log_info "Servi√ßo pronto mas ainda inicializando... aguardando mais 15s"
                sleep 15
            fi
        else
            log_info "Servi√ßo ainda iniciando... ($attempt/$max_attempts) - Replicas: $replicas"
            
            # Mostrar logs a cada 10 tentativas para debug
            if [ $((attempt % 10)) -eq 0 ]; then
                log_info "Verificando logs do Keycloak (tentativa $attempt):"
                docker service logs --tail 15 kryonix-auth_keycloak 2>/dev/null || echo "Logs n√£o dispon√≠veis ainda"
            fi
        fi
        
        sleep 20
        attempt=$((attempt + 1))
    done
    
    if [ $attempt -gt $max_attempts ]; then
        log_error "Timeout aguardando Keycloak ficar pronto"
        log_error "Logs do servi√ßo:"
        docker service logs --tail 30 kryonix-auth_keycloak 2>/dev/null || echo "Logs n√£o dispon√≠veis"
        log_warn "Continuando mesmo assim..."
        return 0
    fi
    
    log_info "$CHECK Deploy do Keycloak conclu√≠do com sucesso na porta $KEYCLOAK_PORT"

    # Corre√ß√£o completa de servi√ßos e proxy
    fix_services_and_proxy
}

# Corrigir servi√ßos e configura√ß√£o do proxy COM REATIVA√á√ÉO INTELIGENTE
fix_services_and_proxy() {
    log_step "Corrigindo servi√ßos e configura√ß√£o do proxy com reativa√ß√£o inteligente"

    # Salvar configura√ß√£o do set -e
    local old_e_setting="$-"
    set +e

    log_info "üìä Status atual dos servi√ßos:"
    docker service ls --format "table {{.Name}}\t{{.Mode}}\t{{.Replicas}}\t{{.Ports}}" 2>/dev/null || true

    # 1. GARANTIR KRYONIX_WEB SEMPRE ATIVO
    log_info "üîÑ Garantindo que Kryonix_web esteja sempre ativo..."

    # Verificar estado atual do Kryonix_web
    local kryonix_web_status=""
    kryonix_web_status=$(docker service ls --format "{{.Name}}\t{{.Replicas}}" 2>/dev/null | grep "Kryonix_web" || echo "")

    if echo "$kryonix_web_status" | grep -q "0/"; then
        log_warn "‚ö†Ô∏è Kryonix_web est√° pausado - REATIVANDO IMEDIATAMENTE"
        local should_reactivate=true
    elif [ -z "$kryonix_web_status" ]; then
        log_warn "‚ö†Ô∏è Kryonix_web n√£o encontrado - pode ter sido removido"
        local should_reactivate=false
    elif echo "$kryonix_web_status" | grep -q "1/1"; then
        log_info "‚úÖ Kryonix_web j√° est√° ativo e funcionando"
        local should_reactivate=false
    else
        log_warn "‚ö†Ô∏è Status do Kryonix_web n√£o identificado: $kryonix_web_status - REATIVANDO"
        local should_reactivate=true
    fi

    # Executar reativa√ß√£o se necess√°rio
    if [ "$should_reactivate" = "true" ]; then
        log_warn "üîÑ Iniciando processo de reativa√ß√£o do Kryonix_web..."

        # Aguardar Keycloak estar est√°vel antes de reativar
        log_info "‚è≥ Aguardando Keycloak estar est√°vel antes da reativa√ß√£o..."
        sleep 20

        # Verificar se Keycloak est√° realmente funcionando na nova porta
        local keycloak_ready=false
        for attempt in {1..5}; do
            if curl -f -s --max-time 10 "http://localhost:$KEYCLOAK_PORT/health/ready" >/dev/null 2>&1; then
                keycloak_ready=true
                log_info "‚úÖ Keycloak confirmado est√°vel na porta $KEYCLOAK_PORT"
                break
            else
                log_info "‚è≥ Aguardando Keycloak ficar est√°vel (tentativa $attempt/5)..."
                sleep 10
            fi
        done

        if [ "$keycloak_ready" = "true" ]; then
            log_info "üîÑ Reativando Kryonix_web agora que Keycloak est√° est√°vel..."

            # Estrat√©gia 1: Scale para 1
            local reactivation_success=false
            local max_attempts=3

            for attempt in $(seq 1 $max_attempts); do
                log_info "üîÑ Tentativa $attempt/$max_attempts de reativar Kryonix_web..."

                if docker service scale Kryonix_web=1 >/dev/null 2>&1; then
                    log_info "‚úÖ Comando de reativa√ß√£o executado (tentativa $attempt)"

                    # Aguardar e verificar se realmente foi reativado
                    log_info "‚è≥ Aguardando Kryonix_web ficar pronto..."
                    sleep 30

                    local new_status=""
                    new_status=$(docker service ls --format "{{.Name}}\t{{.Replicas}}" 2>/dev/null | grep "Kryonix_web" || echo "")

                    if echo "$new_status" | grep -q "1/1"; then
                        log_info "‚úÖ Kryonix_web reativado com sucesso!"
                        reactivation_success=true

                        # Teste adicional - verificar se est√° respondendo
                        sleep 10
                        if curl -f -s --max-time 10 "http://localhost:8080/health" >/dev/null 2>&1; then
                            log_info "‚úÖ Kryonix_web est√° respondendo corretamente!"
                        else
                            log_warn "‚ö†Ô∏è Kryonix_web pode estar com problemas de sa√∫de"
                        fi
                        break
                    elif echo "$new_status" | grep -q "0/1"; then
                        log_warn "‚ö†Ô∏è Kryonix_web ainda iniciando..."
                        sleep 15

                        # Verificar novamente
                        new_status=$(docker service ls --format "{{.Name}}\t{{.Replicas}}" 2>/dev/null | grep "Kryonix_web" || echo "")
                        if echo "$new_status" | grep -q "1/1"; then
                            log_info "‚úÖ Kryonix_web agora est√° ativo!"
                            reactivation_success=true
                            break
                        fi
                    fi
                else
                    log_warn "‚ö†Ô∏è Falha no comando de reativa√ß√£o (tentativa $attempt)"
                fi

                if [ $attempt -lt $max_attempts ]; then
                    log_info "‚è≥ Aguardando antes da pr√≥xima tentativa..."
                    sleep 10
                fi
            done

            # Estrat√©gia 2: Update --force se scale n√£o funcionou
            if [ "$reactivation_success" = "false" ]; then
                log_warn "üîÑ Tentando reativa√ß√£o via update --force..."
                if docker service update --replicas=1 --force Kryonix_web >/dev/null 2>&1; then
                    log_info "‚úÖ Update --force executado"
                    sleep 30

                    local final_status=""
                    final_status=$(docker service ls --format "{{.Name}}\t{{.Replicas}}" 2>/dev/null | grep "Kryonix_web" || echo "")
                    if echo "$final_status" | grep -q "1/1"; then
                        log_info "‚úÖ Kryonix_web reativado via update --force!"
                        reactivation_success=true
                    fi
                fi
            fi

            if [ "$reactivation_success" = "false" ]; then
                log_error "‚ùå Falha ao reativar Kryonix_web ap√≥s todas as tentativas"
                log_error "üîß Solu√ß√£o manual necess√°ria:"
                log_error "   docker service scale Kryonix_web=1"
                log_error "   ou"
                log_error "   docker service update --replicas=1 --force Kryonix_web"
            fi
        else
            log_warn "‚ö†Ô∏è Keycloak n√£o est√° est√°vel - adiando reativa√ß√£o do Kryonix_web"
            log_warn "üîß Execute manualmente ap√≥s verificar Keycloak: docker service scale Kryonix_web=1"
        fi
    fi

    # 2. Verificar conectividade local do Keycloak
    log_info "üîç Testando conectividade local do Keycloak na porta $KEYCLOAK_PORT..."
    local keycloak_local_ok=false

    if curl -f -s --max-time 10 "http://localhost:$KEYCLOAK_PORT" >/dev/null 2>&1; then
        log_info "‚úÖ Keycloak est√° respondendo em http://localhost:$KEYCLOAK_PORT"
        keycloak_local_ok=true
    elif curl -f -s --max-time 10 "http://localhost:$KEYCLOAK_PORT/health/ready" >/dev/null 2>&1; then
        log_info "‚úÖ Keycloak health check OK em http://localhost:$KEYCLOAK_PORT/health/ready"
        keycloak_local_ok=true
    else
        log_warn "‚ö†Ô∏è Keycloak n√£o est√° respondendo ainda na porta $KEYCLOAK_PORT"
        log_info "Aguardando mais 30s para Keycloak inicializar..."
        sleep 30

        # Testar novamente
        if curl -f -s --max-time 10 "http://localhost:$KEYCLOAK_PORT/health/ready" >/dev/null 2>&1; then
            log_info "‚úÖ Keycloak agora est√° respondendo!"
            keycloak_local_ok=true
        else
            log_warn "‚ö†Ô∏è Keycloak ainda n√£o est√° respondendo, mas continuando..."
        fi
    fi

    # 3. Verificar e corrigir configura√ß√£o do Traefik
    log_info "üîß Verificando e corrigindo configura√ß√£o do Traefik..."
    local traefik_found=false

    # Verificar se Traefik est√° rodando como servi√ßo
    if docker service ls --format "{{.Name}}" 2>/dev/null | grep -q "traefik"; then
        local traefik_service=""
        traefik_service=$(docker service ls --format "{{.Name}}" 2>/dev/null | grep "traefik" | head -1)
        log_info "‚úÖ Traefik encontrado como servi√ßo: $traefik_service"
        traefik_found=true
    elif docker ps --format "{{.Names}}" 2>/dev/null | grep -i traefik >/dev/null; then
        log_info "‚úÖ Traefik encontrado como container"
        traefik_found=true
    else
        log_warn "‚ö†Ô∏è Traefik n√£o encontrado! Isso explica o Bad Gateway"
    fi

    # 4. Atualizar labels do Traefik para usar a porta correta do Keycloak
    if [ "$traefik_found" = "true" ]; then
        log_info "üîß Corrigindo labels do Traefik para Keycloak (porta $KEYCLOAK_PORT)..."

        # Atualizar TODOS os labels corretos do Traefik baseados no instalador
        docker service update \
            --label-add traefik.enable=true \
            --label-add traefik.docker.network=Kryonix-NET \
            --label-add traefik.http.services.keycloak.loadbalancer.server.port=8080 \
            --label-add traefik.http.services.keycloak.loadbalancer.healthcheck.path=/health/ready \
            --label-add traefik.http.services.keycloak.loadbalancer.healthcheck.interval=15s \
            --label-add traefik.http.routers.keycloak.rule="Host(\`keycloak.$DOMAIN_BASE\`)" \
            --label-add traefik.http.routers.keycloak.entrypoints=web,websecure \
            --label-add traefik.http.routers.keycloak.service=keycloak \
            --label-add traefik.http.routers.keycloak.priority=1000 \
            --label-add traefik.http.routers.keycloak.tls=true \
            --label-add traefik.http.routers.keycloak.tls.certresolver=letsencrypt \
            kryonix-auth_keycloak >/dev/null 2>&1

        local update_result=$?
        if [ $update_result -eq 0 ]; then
            log_info "‚úÖ Labels do Traefik corrigidos com configura√ß√£o completa"
            log_info "‚è≥ Aguardando Traefik recarregar configura√ß√£o..."
            sleep 20

            # For√ßa reload do Traefik se poss√≠vel
            local traefik_container=""
            traefik_container=$(docker ps --format "{{.Names}}" | grep -i traefik | head -1)
            if [ -n "$traefik_container" ]; then
                log_info "üîÑ For√ßando reload do Traefik..."
                docker kill -s HUP "$traefik_container" 2>/dev/null || true
                sleep 10
            fi
        else
            log_warn "‚ö†Ô∏è Falha ao atualizar labels do Traefik"
        fi
    fi

    # 5. Testar acesso HTTPS do Keycloak e corrigir Bad Gateway
    log_info "üîç Testando acesso HTTPS do Keycloak..."

    # Primeiro teste simples
    local keycloak_https_working=false
    if curl -f -s --max-time 15 "https://keycloak.$DOMAIN_BASE" >/dev/null 2>&1; then
        log_info "‚úÖ Keycloak HTTPS funcionando em https://keycloak.$DOMAIN_BASE"
        keycloak_https_working=true
    else
        log_warn "‚ö†Ô∏è Keycloak HTTPS com problemas - verificando Bad Gateway..."

        # Verificar se √© Bad Gateway espec√≠fico
        local http_code=""
        http_code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "https://keycloak.$DOMAIN_BASE" 2>/dev/null || echo "000")

        if [ "$http_code" = "502" ]; then
            log_error "‚ùå BAD GATEWAY DETECTADO (502) - Corrigindo..."

            # Corrigir configura√ß√£o do Traefik
            if [ "$traefik_found" = "true" ]; then
                log_info "üîß Aplicando corre√ß√£o espec√≠fica para Bad Gateway..."

                # Remover labels antigos e aplicar novos
                docker service update \
                    --label-rm traefik.http.services.keycloak.loadbalancer.server.port \
                    --label-add traefik.http.services.keycloak.loadbalancer.server.port=8080 \
                    --force \
                    kryonix-auth_keycloak >/dev/null 2>&1

                sleep 15

                # Testar novamente
                if curl -f -s --max-time 15 "https://keycloak.$DOMAIN_BASE" >/dev/null 2>&1; then
                    log_info "‚úÖ Bad Gateway corrigido! Keycloak HTTPS funcionando"
                    keycloak_https_working=true
                else
                    log_warn "‚ö†Ô∏è Bad Gateway ainda presente - pode precisar de mais tempo"
                fi
            fi
        elif [ "$http_code" = "000" ]; then
            log_warn "‚ö†Ô∏è Timeout de conex√£o - Traefik pode estar sobrecarregado"
        else
            log_warn "‚ö†Ô∏è C√≥digo HTTP: $http_code - problema diferente de Bad Gateway"
        fi

        if [ "$traefik_found" = "false" ]; then
            log_warn "Causa prov√°vel: Traefik n√£o est√° rodando"
            log_warn "Solu√ß√£o: Configure um proxy reverso (Traefik/Nginx) para SSL/HTTPS"
        elif [ "$keycloak_https_working" = "false" ]; then
            log_warn "Aguarde 2-3 minutos para o SSL ser provisionado e Bad Gateway ser resolvido"
        fi
    fi

    # 6. Status final detalhado
    log_info "üìä Status final dos servi√ßos ap√≥s corre√ß√£o:"
    docker service ls --format "table {{.Name}}\t{{.Mode}}\t{{.Replicas}}\t{{.Ports}}" 2>/dev/null || true

    # 7. Verifica√ß√£o final de sa√∫de dos servi√ßos
    log_info "üè• Verifica√ß√£o final de sa√∫de dos servi√ßos:"

    # Verificar Kryonix_web
    local kryonix_health="‚ùå N√£o respondendo"
    if curl -f -s --max-time 10 "http://localhost:8080/health" >/dev/null 2>&1; then
        kryonix_health="‚úÖ Saud√°vel"
    elif curl -f -s --max-time 10 "http://localhost:8080" >/dev/null 2>&1; then
        kryonix_health="‚ö†Ô∏è Respondendo (sem health check)"
    fi

    # Verificar Keycloak
    local keycloak_health="‚ùå N√£o respondendo"
    if curl -f -s --max-time 10 "http://localhost:$KEYCLOAK_PORT/health/ready" >/dev/null 2>&1; then
        keycloak_health="‚úÖ Saud√°vel"
    elif curl -f -s --max-time 10 "http://localhost:$KEYCLOAK_PORT" >/dev/null 2>&1; then
        keycloak_health="‚ö†Ô∏è Respondendo (inicializando)"
    fi

    # 8. Resumo detalhado para o usu√°rio
    log_info ""
    log_info "üéØ RESUMO DETALHADO DA CORRE√á√ÉO:"
    log_info "========================================"

    local kryonix_final=""
    kryonix_final=$(docker service ls --format "{{.Name}}\t{{.Replicas}}" 2>/dev/null | grep "Kryonix_web" || echo "n√£o encontrado")
    local keycloak_final=""
    keycloak_final=$(docker service ls --format "{{.Name}}\t{{.Replicas}}" 2>/dev/null | grep "kryonix-auth_keycloak" || echo "n√£o encontrado")

    log_info "üìã Kryonix_web: $kryonix_final - Sa√∫de: $kryonix_health"
    log_info "üìã Keycloak: $keycloak_final - Sa√∫de: $keycloak_health"
    log_info "üìã Traefik: $([ "$traefik_found" = "true" ] && echo "encontrado e configurado" || echo "n√£o encontrado")"
    log_info "üìã Porta Keycloak: $KEYCLOAK_PORT"
    log_info "üìã Conflito Resolvido: $([ "${KRYONIX_WEB_WAS_RUNNING}" = "true" ] && echo "Sim - Kryonix_web foi pausado e reativado" || echo "N√£o houve conflito")"

    log_info ""
    log_info "üåê URLs de acesso validadas:"
    log_info "   ‚Ä¢ Kryonix Web: http://localhost:8080 ou https://$DOMAIN_BASE"
    log_info "   ‚Ä¢ Keycloak Local: http://localhost:$KEYCLOAK_PORT"
    log_info "   ‚Ä¢ Keycloak HTTPS: https://keycloak.$DOMAIN_BASE"
    log_info "   ‚Ä¢ Admin Keycloak: https://keycloak.$DOMAIN_BASE/admin"

    log_info ""
    log_info "üîß Comandos de verifica√ß√£o manual:"
    log_info "   ‚Ä¢ Status servi√ßos: docker service ls"
    log_info "   ‚Ä¢ Logs Kryonix: docker service logs Kryonix_web"
    log_info "   ‚Ä¢ Logs Keycloak: docker service logs kryonix-auth_keycloak"
    log_info "   ‚Ä¢ Teste Kryonix: curl http://localhost:8080/health"
    log_info "   ‚Ä¢ Teste Keycloak: curl http://localhost:$KEYCLOAK_PORT/health/ready"
    log_info "   ‚Ä¢ Teste HTTPS: curl -I https://keycloak.$DOMAIN_BASE"

    log_info ""
    log_info "üö® CORRE√á√ÉO PARA BAD GATEWAY:"
    log_info "   Se ainda houver Bad Gateway em https://keycloak.$DOMAIN_BASE:"
    log_info "   1. Verificar Traefik: docker service logs traefik (se houver)"
    log_info "   2. Recarregar labels: docker service update --force kryonix-auth_keycloak"
    log_info "   3. Aguardar 2-3 minutos para SSL/Traefik se estabilizar"
    log_info "   4. Keycloak est√° na porta $KEYCLOAK_PORT internamente (8080 do container)"

    # Salvar informa√ß√µes de estado para refer√™ncia futura
    cat > "$CONFIG_DIR/.service-status" << STATUS_EOF
# KRYONIX - Status dos Servi√ßos Parte 01
KEYCLOAK_PORT=$KEYCLOAK_PORT
KRYONIX_WEB_WAS_RUNNING=${KRYONIX_WEB_WAS_RUNNING}
KEYCLOAK_FORCE_ALT_PORT=${KEYCLOAK_FORCE_ALT_PORT}
DEPLOYMENT_DATE=$(date '+%Y-%m-%d %H:%M:%S')
KRYONIX_WEB_STATUS=$kryonix_final
KEYCLOAK_STATUS=$keycloak_final
KRYONIX_HEALTH=$kryonix_health
KEYCLOAK_HEALTH=$keycloak_health
STATUS_EOF

    log_info "üìÑ Status salvo em: $CONFIG_DIR/.service-status"

    # Restaurar configura√ß√£o do set -e se estava ativa
    if [[ "$old_e_setting" == *e* ]]; then
        set -e
    fi

    log_info "$CHECK Corre√ß√£o de servi√ßos e proxy conclu√≠da com sucesso!"
}

# Verificar e configurar Keycloak existente
check_existing_keycloak() {
    log_step "Verificando Keycloak existente"

    # Aguardar mais tempo para Keycloak inicializar completamente
    log_info "Aguardando Keycloak estar totalmente pronto..."
    sleep 45

    # Verificar se Keycloak est√° acess√≠vel usando a porta configurada
    local keycloak_port="${KEYCLOAK_PORT:-8080}"
    local keycloak_urls=(
        "http://localhost:$keycloak_port"
        "http://127.0.0.1:$keycloak_port"
        "https://keycloak.$DOMAIN_BASE"
        "http://localhost:$keycloak_port/health/ready"
        "http://127.0.0.1:$keycloak_port/health/ready"
        "https://keycloak.$DOMAIN_BASE/health/ready"
    )

    local keycloak_found=false
    local keycloak_url=""

    for url in "${keycloak_urls[@]}"; do
        log_info "Testando acesso: $url"
        
        # Testar m√∫ltiplas vezes cada URL
        for attempt in {1..3}; do
            if curl -f -s --max-time 15 --connect-timeout 10 "$url" > /dev/null 2>&1; then
                keycloak_found=true
                keycloak_url="$url"
                log_info "$CHECK Keycloak encontrado em: $url (tentativa $attempt)"
                break 2
            fi
            sleep 5
        done
    done

    if [ "$keycloak_found" = false ]; then
        log_warn "‚ö†Ô∏è Keycloak n√£o acess√≠vel ainda em nenhuma URL"
        log_warn "URLs testadas: ${keycloak_urls[*]}"
        log_warn "Verificando logs do servi√ßo..."
        docker service logs --tail 20 kryonix-auth_keycloak 2>/dev/null || echo "Logs n√£o dispon√≠veis"
        
        # N√£o falhar aqui - continuar para configura√ß√£o manual
        export KEYCLOAK_BASE_URL="http://localhost:$keycloak_port"
        log_warn "Usando URL padr√£o: $KEYCLOAK_BASE_URL"
        return 0
    fi

    # Definir URL base do Keycloak (remover /health/ready se presente)
    export KEYCLOAK_BASE_URL="${keycloak_url%/health/ready}"
    
    # Se for localhost, definir a URL p√∫blica para configura√ß√£o
    if [[ "$KEYCLOAK_BASE_URL" == *"localhost"* ]] || [[ "$KEYCLOAK_BASE_URL" == *"127.0.0.1"* ]]; then
        export KEYCLOAK_PUBLIC_URL="https://keycloak.$DOMAIN_BASE"
    else
        export KEYCLOAK_PUBLIC_URL="$KEYCLOAK_BASE_URL"
    fi

    log_info "$CHECK Keycloak configurado para: $KEYCLOAK_BASE_URL"
    log_info "$CHECK URL p√∫blica: $KEYCLOAK_PUBLIC_URL"
    return 0
}

# Fun√ß√£o para fazer requisi√ß√µes ao Keycloak com retry
keycloak_request() {
    local method="$1"
    local url="$2"
    local data="$3"
    local max_attempts=3
    
    for i in $(seq 1 $max_attempts); do
        local response_code
        if [ -n "$data" ]; then
            response_code=$(curl -s -w "%{http_code}" -o /dev/null --max-time 30 \
                -X "$method" \
                -H "Authorization: Bearer $ADMIN_TOKEN" \
                -H "Content-Type: application/json" \
                -d "$data" \
                "$url")
        else
            response_code=$(curl -s -w "%{http_code}" -o /dev/null --max-time 30 \
                -X "$method" \
                -H "Authorization: Bearer $ADMIN_TOKEN" \
                "$url")
        fi
        
        # Considerar 201, 200 e 409 (conflito) como sucesso para idempot√™ncia
        if [[ "$response_code" =~ ^(200|201|409)$ ]]; then
            return 0
        fi
        
        log_warn "Tentativa $i/$max_attempts falhou com c√≥digo $response_code"
        sleep 2
    done
    
    log_error "Falha na requisi√ß√£o ap√≥s $max_attempts tentativas: $method $url"
    return 1
}

# Configurar Realm e Clients do Keycloak
configure_keycloak_realm() {
    log_step "Configurando Realm e Clients do Keycloak"
    
    # Aguardar Keycloak estar totalmente pronto
    log_info "Aguardando Keycloak estar totalmente inicializado..."
    sleep 30
    
    # Tentar diferentes URLs para obter token admin
    local admin_token=""
    local keycloak_urls=(
        "http://localhost:8080"
        "http://127.0.0.1:8080"
        "https://keycloak.$DOMAIN_BASE"
        "$KEYCLOAK_BASE_URL"
    )
    
    for url in "${keycloak_urls[@]}"; do
        log_info "Tentando obter token admin via: $url"
        
        # Tentar m√∫ltiplas vezes com cada URL
        for attempt in {1..5}; do
            local token_response
            token_response=$(curl -s --max-time 30 --connect-timeout 10 \
                -d "client_id=admin-cli" \
                -d "username=$KEYCLOAK_ADMIN_USER" \
                -d "password=$KEYCLOAK_ADMIN_PASSWORD" \
                -d "grant_type=password" \
                "$url/realms/master/protocol/openid_connect/token" 2>/dev/null || echo "")
            
            if [ -n "$token_response" ]; then
                admin_token=$(echo "$token_response" | jq -r '.access_token' 2>/dev/null || echo "")
                
                if [ -n "$admin_token" ] && [ "$admin_token" != "null" ]; then
                    log_info "‚úÖ Token admin obtido com sucesso via $url (tentativa $attempt)"
                    export KEYCLOAK_BASE_URL="$url"
                    break 2
                else
                    log_warn "Tentativa $attempt falhou via $url: $(echo "$token_response" | head -c 200)..."
                fi
            else
                log_warn "Tentativa $attempt falhou via $url: sem resposta"
            fi
            
            sleep 5
        done
    done
    
    if [ -z "$admin_token" ] || [ "$admin_token" = "null" ]; then
        log_error "Falha ao obter token admin do Keycloak ap√≥s todas as tentativas"
        log_error "URLs testadas: ${keycloak_urls[*]}"
        log_error "Credenciais utilizadas: $KEYCLOAK_ADMIN_USER / $KEYCLOAK_ADMIN_PASSWORD"
        
        # Verificar se Keycloak est√° realmente funcionando
        log_info "Verificando status do servi√ßo Keycloak..."
        docker service logs --tail 20 kryonix-auth_keycloak 2>/dev/null || echo "Logs n√£o dispon√≠veis"
        
        # Continuar mesmo assim para mostrar as credenciais
        log_warn "Continuando sem configurar realm (pode ser feito manualmente)..."
        return 0
    fi
    
    # Definir vari√°vel global para uso em outras fun√ß√µes
    ADMIN_TOKEN="$admin_token"
    log_info "$CHECK Token admin obtido"
    
    # Verificar se realm KRYONIX j√° existe
    if curl -s -H "Authorization: Bearer $ADMIN_TOKEN" \
       "$KEYCLOAK_BASE_URL/admin/realms/KRYONIX" > /dev/null 2>&1; then
        log_info "$CHECK Realm KRYONIX j√° existe"
    else
        log_info "Criando Realm KRYONIX..."
        
        # Criar realm com configura√ß√£o completa
        keycloak_request "POST" "$KEYCLOAK_BASE_URL/admin/realms" '{
            "realm": "KRYONIX",
            "enabled": true,
            "displayName": "KRYONIX - Plataforma SaaS",
            "displayNameHtml": "<strong>KRYONIX</strong> - Sua Plataforma de Neg√≥cios",
            "defaultLocale": "pt-BR",
            "internationalizationEnabled": true,
            "supportedLocales": ["pt-BR"],
            "registrationAllowed": false,
            "registrationEmailAsUsername": true,
            "rememberMe": true,
            "verifyEmail": false,
            "loginWithEmailAllowed": true,
            "duplicateEmailsAllowed": false,
            "resetPasswordAllowed": true,
            "editUsernameAllowed": false,
            "bruteForceProtected": true,
            "permanentLockout": false,
            "maxFailureWaitSeconds": 900,
            "minimumQuickLoginWaitSeconds": 60,
            "waitIncrementSeconds": 60,
            "quickLoginCheckMilliSeconds": 1000,
            "maxDeltaTimeSeconds": 43200,
            "failureFactor": 5,
            "loginTheme": "keycloak",
            "accountTheme": "keycloak",
            "adminTheme": "keycloak",
            "emailTheme": "keycloak",
            "attributes": {
                "multi_tenant": "true",
                "mobile_priority": "true",
                "created_at": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"
            }
        }'
        
        log_info "$CHECK Realm KRYONIX criado"
    fi
    
    # Configurar clients necess√°rios
    configure_keycloak_clients
    
    # Criar usu√°rios padr√£o
    create_keycloak_users
}

# Configurar clients do Keycloak
configure_keycloak_clients() {
    log_info "Configurando clients do Keycloak..."
    
    # Client Frontend
    keycloak_request "POST" "$KEYCLOAK_BASE_URL/admin/realms/KRYONIX/clients" '{
        "clientId": "kryonix-frontend",
        "name": "KRYONIX Frontend",
        "enabled": true,
        "clientAuthenticatorType": "client-secret",
        "secret": "kryonix-frontend-secret-2025",
        "redirectUris": [
            "https://app.'$DOMAIN_BASE'/*",
            "https://www.'$DOMAIN_BASE'/*",
            "https://*.'$DOMAIN_BASE'/*",
            "http://localhost:3000/*"
        ],
        "webOrigins": [
            "https://app.'$DOMAIN_BASE'",
            "https://www.'$DOMAIN_BASE'",
            "https://*.'$DOMAIN_BASE'",
            "http://localhost:3000"
        ],
        "protocol": "openid-connect",
        "publicClient": false,
        "standardFlowEnabled": true,
        "implicitFlowEnabled": false,
        "directAccessGrantsEnabled": true,
        "serviceAccountsEnabled": true,
        "authorizationServicesEnabled": true,
        "fullScopeAllowed": true
    }'
    
    # Client Mobile
    keycloak_request "POST" "$KEYCLOAK_BASE_URL/admin/realms/KRYONIX/clients" '{
        "clientId": "kryonix-mobile-app",
        "name": "KRYONIX Mobile App",
        "enabled": true,
        "clientAuthenticatorType": "client-secret",
        "secret": "kryonix-mobile-secret-2025",
        "redirectUris": [
            "kryonix://auth/callback",
            "https://app.'$DOMAIN_BASE'/mobile/callback"
        ],
        "webOrigins": ["*"],
        "protocol": "openid-connect",
        "publicClient": false,
        "standardFlowEnabled": true,
        "implicitFlowEnabled": false,
        "directAccessGrantsEnabled": true,
        "serviceAccountsEnabled": false,
        "authorizationServicesEnabled": false,
        "fullScopeAllowed": true
    }'
    
    # Client IA
    keycloak_request "POST" "$KEYCLOAK_BASE_URL/admin/realms/KRYONIX/clients" '{
        "clientId": "kryonix-ai-client",
        "name": "KRYONIX IA Integration",
        "enabled": true,
        "clientAuthenticatorType": "client-secret",
        "secret": "kryonix-ai-secret-2025",
        "protocol": "openid-connect",
        "publicClient": false,
        "standardFlowEnabled": false,
        "directAccessGrantsEnabled": true,
        "serviceAccountsEnabled": true,
        "fullScopeAllowed": true
    }'
    
    log_info "$CHECK Clients do Keycloak configurados"
}

# Criar usu√°rios padr√£o
create_keycloak_users() {
    log_info "Criando usu√°rios padr√£o..."
    
    # Usu√°rio master
    keycloak_request "POST" "$KEYCLOAK_BASE_URL/admin/realms/KRYONIX/users" '{
        "username": "'$KEYCLOAK_ADMIN_USER'",
        "email": "admin@'$DOMAIN_BASE'",
        "firstName": "KRYONIX",
        "lastName": "Master",
        "enabled": true,
        "emailVerified": true,
        "credentials": [{
            "type": "password",
            "value": "'$KEYCLOAK_ADMIN_PASSWORD'",
            "temporary": false
        }],
        "attributes": {
            "whatsapp": ["'$WHATSAPP_ALERT'"],
            "role": ["admin"]
        }
    }'
    
    # Usu√°rio IA
    keycloak_request "POST" "$KEYCLOAK_BASE_URL/admin/realms/KRYONIX/users" '{
        "username": "kryonix-ai-service",
        "email": "ai@'$DOMAIN_BASE'",
        "firstName": "KRYONIX",
        "lastName": "IA Service",
        "enabled": true,
        "emailVerified": true,
        "credentials": [{
            "type": "password",
            "value": "ai_kryonix_2025",
            "temporary": false
        }],
        "attributes": {
            "service": ["ai"],
            "role": ["service"]
        }
    }'
    
    log_info "$CHECK Usu√°rios padr√£o criados"
}

# ============================================================================
# SCRIPTS DE AUTOMA√á√ÉO
# ============================================================================

# Configurar scripts de automa√ß√£o
setup_automation_scripts() {
    log_step "Configurando scripts de automa√ß√£o"
    
    # Script de cria√ß√£o autom√°tica de cliente
    if [ ! -f "$SCRIPTS_DIR/kryonix-create-client.sh" ]; then
        log_info "Criando script de cria√ß√£o de cliente..."
        cat > "$SCRIPTS_DIR/kryonix-create-client.sh" << 'AUTOCREATE_EOF'
#!/bin/bash
# KRYONIX - Cria√ß√£o Autom√°tica de Cliente
# Uso: kryonix-create-client.sh <nome_cliente> <email_admin> <whatsapp> <modulos>

set -euo pipefail

CLIENTE_NOME="$1"
ADMIN_EMAIL="$2"
WHATSAPP="$3"
MODULOS="$4"

if [ $# -lt 4 ]; then
    echo "Uso: $0 <nome_cliente> <email_admin> <whatsapp> <modulos>"
    echo "Exemplo: $0 'Cl√≠nica Exemplo' 'admin@clinica.com' '+5517999999999' 'crm,agendamento,whatsapp'"
    exit 1
fi

# Gerar ID do cliente
CLIENTE_ID=$(echo "$CLIENTE_NOME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g' | cut -c1-20)
REALM_NAME="kryonix-cliente-${CLIENTE_ID}"
TEMP_PASSWORD=$(openssl rand -base64 12)

echo "üöÄ Criando cliente: $CLIENTE_ID"

# Verificar se cliente j√° existe
if [ -f "/opt/kryonix/clients/${CLIENTE_ID}.env" ]; then
    echo "‚ö†Ô∏è Cliente $CLIENTE_ID j√° existe!"
    exit 1
fi

# Obter token admin
ADMIN_TOKEN=$(curl -s --max-time 30 \
    -d "client_id=admin-cli" \
    -d "username=kryonix" \
    -d "password=${KEYCLOAK_ADMIN_PASSWORD:-Vitor@123456}" \
    -d "grant_type=password" \
    "https://keycloak.kryonix.com.br/realms/master/protocol/openid_connect/token" | \
    python3 -c "import sys, json; print(json.load(sys.stdin)['access_token'])" 2>/dev/null || echo "")

if [ -z "$ADMIN_TOKEN" ]; then
    echo "‚ùå Falha ao obter token admin"
    exit 1
fi

# Criar realm
echo "üèóÔ∏è Criando realm $REALM_NAME..."
curl -s --max-time 30 -X POST "https://keycloak.kryonix.com.br/admin/realms" \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d "{
        \"realm\": \"$REALM_NAME\",
        \"enabled\": true,
        \"displayName\": \"KRYONIX - $CLIENTE_NOME\",
        \"attributes\": {
            \"cliente_id\": \"$CLIENTE_ID\",
            \"cliente_nome\": \"$CLIENTE_NOME\",
            \"modulos_contratados\": \"$MODULOS\",
            \"created_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
        }
    }" > /dev/null

# Criar client
echo "üîß Configurando client..."
curl -s --max-time 30 -X POST "https://keycloak.kryonix.com.br/admin/realms/$REALM_NAME/clients" \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d "{
        \"clientId\": \"kryonix-frontend\",
        \"enabled\": true,
        \"redirectUris\": [\"https://${CLIENTE_ID}.kryonix.com.br/*\"],
        \"webOrigins\": [\"https://${CLIENTE_ID}.kryonix.com.br\"],
        \"directAccessGrantsEnabled\": true
    }" > /dev/null

# Criar usu√°rio admin
echo "üë§ Criando usu√°rio admin..."
curl -s --max-time 30 -X POST "https://keycloak.kryonix.com.br/admin/realms/$REALM_NAME/users" \
    -H "Authorization: Bearer $ADMIN_TOKEN" \
    -H "Content-Type: application/json" \
    -d "{
        \"username\": \"$ADMIN_EMAIL\",
        \"email\": \"$ADMIN_EMAIL\",
        \"enabled\": true,
        \"emailVerified\": true,
        \"credentials\": [{
            \"type\": \"password\",
            \"value\": \"$TEMP_PASSWORD\",
            \"temporary\": true
        }],
        \"attributes\": {
            \"cliente_id\": [\"$CLIENTE_ID\"],
            \"whatsapp\": [\"$WHATSAPP\"]
        }
    }" > /dev/null

# Configurar subdom√≠nio no Traefik
echo "üåê Configurando subdom√≠nio..."
cat > "/etc/traefik/dynamic/${CLIENTE_ID}.yml" << TRAEFIK_EOF
http:
  routers:
    ${CLIENTE_ID}-router:
      rule: "Host(\`${CLIENTE_ID}.kryonix.com.br\`)"
      service: ${CLIENTE_ID}-service
      tls:
        certResolver: letsencrypt
  services:
    ${CLIENTE_ID}-service:
      loadBalancer:
        servers:
          - url: "http://frontend:3000"
TRAEFIK_EOF

# Salvar configura√ß√£o do cliente
echo "‚öôÔ∏è Salvando configura√ß√£o..."
cat > "/opt/kryonix/clients/${CLIENTE_ID}.env" << CONFIG_EOF
CLIENTE_ID=${CLIENTE_ID}
CLIENTE_NOME=${CLIENTE_NOME}
ADMIN_EMAIL=${ADMIN_EMAIL}
WHATSAPP=${WHATSAPP}
MODULOS=${MODULOS}
REALM_NAME=${REALM_NAME}
SUBDOMAIN=${CLIENTE_ID}.kryonix.com.br
TEMP_PASSWORD=${TEMP_PASSWORD}
CREATED_AT=$(date -u +%Y-%m-%dT%H:%M:%SZ)
CONFIG_EOF

# Enviar credenciais via WhatsApp
echo "üì± Tentando enviar credenciais via WhatsApp..."
if command -v curl >/dev/null 2>&1; then
    curl -s --max-time 10 -X POST "https://api.kryonix.com.br/message/sendText/kryonix" \
        -H "apikey: ${EVOLUTION_API_KEY:-2f4d6967043b87b5ebee57b872e0223a}" \
        -H "Content-Type: application/json" \
        -d "{
            \"number\": \"$WHATSAPP\",
            \"text\": \"üéâ KRYONIX - Plataforma Pronta!\\n\\nüåê Acesso: https://${CLIENTE_ID}.kryonix.com.br\\nüë§ Email: $ADMIN_EMAIL\\nüîë Senha: $TEMP_PASSWORD\\n\\nüìã M√≥dulos: $MODULOS\"
        }" > /dev/null 2>&1 || echo "‚ö†Ô∏è Aviso: Falha ao enviar WhatsApp"
fi

echo "‚úÖ Cliente $CLIENTE_ID criado com sucesso!"
echo "üåê Acesso: https://${CLIENTE_ID}.kryonix.com.br"
echo "üìß Admin: $ADMIN_EMAIL"
echo "üîë Senha tempor√°ria: $TEMP_PASSWORD"
AUTOCREATE_EOF

        chmod +x "$SCRIPTS_DIR/kryonix-create-client.sh"
        log_info "$CHECK Script de cria√ß√£o de cliente criado"
    fi
    
    # Script de valida√ßÔøΩÔøΩo de clientes
    if [ ! -f "$SCRIPTS_DIR/kryonix-validate-clients.sh" ]; then
        log_info "Criando script de valida√ß√£o de clientes..."
        cat > "$SCRIPTS_DIR/kryonix-validate-clients.sh" << 'VALIDATE_EOF'
#!/bin/bash
set -euo pipefail

echo "üîç Validando clientes KRYONIX..."

# Validar clientes existentes
for config_file in /opt/kryonix/clients/*.env; do
    if [ -f "$config_file" ]; then
        source "$config_file"
        echo "üè¢ Cliente: $CLIENTE_ID"
        
        # Verificar subdom√≠nio
        if curl -s -I --max-time 10 "https://${CLIENTE_ID}.kryonix.com.br" > /dev/null 2>&1; then
            echo "‚úÖ Subdom√≠nio $CLIENTE_ID acess√≠vel"
        else
            echo "‚ùå Subdom√≠nio $CLIENTE_ID n√£o acess√≠vel"
        fi
        echo ""
    fi
done

echo "üéØ Valida√ß√£o conclu√≠da!"
VALIDATE_EOF

        chmod +x "$SCRIPTS_DIR/kryonix-validate-clients.sh"
        log_info "$CHECK Script de valida√ß√£o criado"
    fi
    
    log_info "$CHECK Scripts de automa√ß√£o configurados"
}

# ============================================================================
# MONITORAMENTO E BACKUP
# ============================================================================

# Configurar monitoramento
setup_monitoring() {
    log_step "Configurando monitoramento avan√ßado"
    
    # Script de monitoramento
    if [ ! -f "$SCRIPTS_DIR/monitor-kryonix.sh" ]; then
        log_info "Criando script de monitoramento..."
        cat > "$SCRIPTS_DIR/monitor-kryonix.sh" << 'MONITOR_EOF'
#!/bin/bash
set -euo pipefail

LOG_FILE="/opt/kryonix/logs/monitor.log"
ALERT_COOLDOWN_FILE="/tmp/kryonix-alert-cooldown"
COOLDOWN_MINUTES=30

log_monitor() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

send_alert() {
    local message="$1"
    
    # Verificar cooldown para evitar spam
    if [ -f "$ALERT_COOLDOWN_FILE" ]; then
        local last_alert=$(cat "$ALERT_COOLDOWN_FILE")
        local now=$(date +%s)
        local diff=$((now - last_alert))
        if [ $diff -lt $((COOLDOWN_MINUTES * 60)) ]; then
            log_monitor "‚è≥ Alerta em cooldown, aguardando $(( (COOLDOWN_MINUTES * 60 - diff) / 60 )) minutos"
            return
        fi
    fi
    
    if curl -s --max-time 10 -X POST "https://api.kryonix.com.br/message/sendText/kryonix" \
        -H "apikey: ${EVOLUTION_API_KEY:-2f4d6967043b87b5ebee57b872e0223a}" \
        -H "Content-Type: application/json" \
        -d "{
            \"number\": \"${WHATSAPP_ALERT:-+5517981805327}\",
            \"text\": \"ÔøΩÔøΩÔøΩÔøΩ ALERTA KRYONIX\\n\\n$message\\n\\n‚è∞ $(date '+%d/%m/%Y %H:%M:%S')\"
        }" > /dev/null 2>&1; then
        echo "$(date +%s)" > "$ALERT_COOLDOWN_FILE"
        log_monitor "üì± Alerta enviado: $message"
    fi
}

# Loop principal
trap 'log_monitor "Monitor interrompido"; exit 0' INT TERM

while true; do
    # Verificar Keycloak
    if ! curl -f -s --max-time 10 https://keycloak.kryonix.com.br/health/ready > /dev/null 2>&1; then
        log_monitor "üö® CR√çTICO: Keycloak n√£o est√° respondendo!"
        send_alert "KEYCLOAK OFFLINE - Servi√ßo de autentica√ß√£o n√£o est√° respondendo"
        
        # Tentar restart uma vez
        if docker service update --force kryonix-auth_keycloak 2>/dev/null; then
            log_monitor "üîÑ Tentativa de restart do Keycloak executada"
            sleep 60
        fi
    else
        log_monitor "‚úÖ Keycloak funcionando normalmente"
    fi
    
    # Verificar PostgreSQL
    if [ "$POSTGRES_CONTAINER" = "external-supabase" ]; then
        if ! PGPASSWORD="$POSTGRES_PASSWORD" pg_isready -h "$POSTGRES_HOST" -U postgres > /dev/null 2>&1; then
            log_monitor "üö® CR√çTICO: Supabase PostgreSQL n√£o est√° respondendo!"
            send_alert "SUPABASE POSTGRESQL OFFLINE - Banco de dados n√£o est√° respondendo"
        else
            log_monitor "‚úÖ Supabase PostgreSQL funcionando normalmente"
        fi
    else
        if ! docker exec $POSTGRES_CONTAINER pg_isready -U postgres > /dev/null 2>&1; then
            log_monitor "üö® CR√çTICO: PostgreSQL n√£o est√° respondendo!"
            send_alert "POSTGRESQL OFFLINE - Banco de dados n√£o est√° respondendo"
        else
            log_monitor "‚úÖ PostgreSQL funcionando normalmente"
        fi
    fi
    
    # Verificar uso de disco
    DISK_USAGE=$(df / | awk 'NR==2 {print $5}' | sed 's/%//' || echo "0")
    if [ "$DISK_USAGE" -gt 85 ]; then
        log_monitor "‚ö†Ô∏è AVISO: Uso de disco alto: ${DISK_USAGE}%"
        send_alert "DISCO CHEIO - Uso: ${DISK_USAGE}% - Limpeza recomendada"
    fi
    
    # Verificar uso de mem√≥ria
    MEMORY_USAGE=$(free | awk 'NR==2{printf "%.0f", $3*100/$2}' || echo "0")
    if [ "$MEMORY_USAGE" -gt 90 ]; then
        log_monitor "‚ö†Ô∏è AVISO: Uso de mem√≥ria alto: ${MEMORY_USAGE}%"
        send_alert "MEM√ìRIA ALTA - Uso: ${MEMORY_USAGE}% - Verifica√ß√£o necess√°ria"
    fi
    
    # Aguardar 5 minutos antes da pr√≥xima verifica√ß√£o
    sleep 300
done
MONITOR_EOF

        chmod +x "$SCRIPTS_DIR/monitor-kryonix.sh"
        log_info "$CHECK Script de monitoramento criado"
    fi
    
    # Criar servi√ßo systemd
    if [ ! -f "/etc/systemd/system/kryonix-monitor.service" ]; then
        log_info "Criando servi√ßo de monitoramento..."
        cat > /etc/systemd/system/kryonix-monitor.service << 'SERVICE_EOF'
[Unit]
Description=KRYONIX System Monitor
After=docker.service
Requires=docker.service

[Service]
Type=simple
User=root
ExecStart=/opt/kryonix/scripts/monitor-kryonix.sh
Restart=always
RestartSec=30
Environment=KEYCLOAK_ADMIN_PASSWORD=Vitor@123456
Environment=EVOLUTION_API_KEY=2f4d6967043b87b5ebee57b872e0223a
Environment=WHATSAPP_ALERT=+5517981805327

[Install]
WantedBy=multi-user.target
SERVICE_EOF

        systemctl daemon-reload
        systemctl enable kryonix-monitor
        log_info "$CHECK Servi√ßo de monitoramento criado"
    fi
    
    # Iniciar servi√ßo
    if ! systemctl is-active --quiet kryonix-monitor; then
        systemctl start kryonix-monitor
        log_info "$CHECK Servi√ßo de monitoramento iniciado"
    else
        log_info "$CHECK Servi√ßo de monitoramento j√° est√° rodando"
    fi
}

# Configurar backup autom√°tico
setup_backup() {
    log_step "Configurando backup autom√°tico"
    
    # Script de backup
    if [ ! -f "$SCRIPTS_DIR/backup-kryonix.sh" ]; then
        log_info "Criando script de backup..."
        cat > "$SCRIPTS_DIR/backup-kryonix.sh" << 'BACKUP_EOF'
#!/bin/bash
set -euo pipefail

BACKUP_DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/opt/kryonix/backups/$BACKUP_DATE"
mkdir -p "$BACKUP_DIR"

log_backup() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> /opt/kryonix/logs/backup.log
}

log_backup "üíæ Iniciando backup KRYONIX completo..."

# Backup Keycloak (database)
log_backup "üîê Backup Keycloak..."
if [ "$POSTGRES_CONTAINER" = "external-supabase" ]; then
    if PGPASSWORD="$POSTGRES_PASSWORD" pg_dump -h "$POSTGRES_HOST" -U postgres -d keycloak > "$BACKUP_DIR/keycloak_db.sql" 2>/dev/null; then
        gzip "$BACKUP_DIR/keycloak_db.sql"
        log_backup "‚úÖ Backup Keycloak Supabase conclu√≠do"
    else
        log_backup "‚ùå Falha no backup Keycloak Supabase"
    fi
else
    if docker exec $POSTGRES_CONTAINER pg_dump -h 127.0.0.1 -U postgres -d keycloak > "$BACKUP_DIR/keycloak_db.sql" 2>/dev/null; then
        gzip "$BACKUP_DIR/keycloak_db.sql"
        log_backup "‚úÖ Backup Keycloak conclu√≠do"
    else
        log_backup "‚ùå Falha no backup Keycloak"
    fi
fi

# Backup configura√ß√µes dos clientes
log_backup "üë• Backup configura√ß√µes clientes..."
if [ -d "/opt/kryonix/clients" ]; then
    cp -r /opt/kryonix/clients "$BACKUP_DIR/" 2>/dev/null || true
fi

# Backup configura√ß√µes Traefik
log_backup "üåê Backup configura√ß√µes Traefik..."
if [ -d "/etc/traefik/dynamic" ]; then
    cp -r /etc/traefik/dynamic "$BACKUP_DIR/traefik_dynamic" 2>/dev/null || true
fi

# Backup scripts
log_backup "üõ†Ô∏è Backup scripts..."
if [ -d "/opt/kryonix/scripts" ]; then
    cp -r /opt/kryonix/scripts "$BACKUP_DIR/" 2>/dev/null || true
fi

# Calcular tamanho do backup
BACKUP_SIZE=$(du -sh "$BACKUP_DIR" 2>/dev/null | cut -f1 || echo "N/A")
log_backup "‚úÖ Backup KRYONIX conclu√≠do: $BACKUP_DIR ($BACKUP_SIZE)"

# Limpar backups antigos (manter √∫ltimos 30 dias)
find /opt/kryonix/backups -type d -name "202*" -mtime +30 -exec rm -rf {} \; 2>/dev/null || true

# Notificar via WhatsApp
if command -v curl >/dev/null 2>&1; then
    curl -s --max-time 10 -X POST "https://api.kryonix.com.br/message/sendText/kryonix" \
        -H "apikey: ${EVOLUTION_API_KEY:-2f4d6967043b87b5ebee57b872e0223a}" \
        -H "Content-Type: application/json" \
        -d "{
            \"number\": \"${WHATSAPP_ALERT:-+5517981805327}\",
            \"text\": \"üíæ BACKUP KRYONIX CONCLU√çDO\\n\\nüìÖ Data: $BACKUP_DATE\\nüìä Tamanho: $BACKUP_SIZE\"
        }" > /dev/null 2>&1 || true
fi

log_backup "ÔøΩÔøΩÔøΩ Processo de backup finalizado"
BACKUP_EOF

        chmod +x "$SCRIPTS_DIR/backup-kryonix.sh"
        log_info "$CHECK Script de backup criado"
    fi
    
    # Configurar cron para backup di√°rio
    if ! crontab -l 2>/dev/null | grep -q "backup-kryonix.sh"; then
        log_info "Agendando backup di√°rio √†s 2h..."
        (crontab -l 2>/dev/null; echo "0 2 * * * $SCRIPTS_DIR/backup-kryonix.sh") | crontab -
        log_info "$CHECK Backup autom√°tico agendado"
    else
        log_info "$CHECK Backup autom√°tico j√° est√° agendado"
    fi
}

# ============================================================================
# CONFIGURA√áÔøΩÔøΩES DO AMBIENTE
# ============================================================================

# Configurar vari√°veis de ambiente
setup_environment() {
    log_step "Configurando vari√°veis de ambiente"
    
    if [ ! -f "$CONFIG_DIR/.env" ]; then
        log_info "Criando arquivo de vari√°veis de ambiente..."
        cat > "$CONFIG_DIR/.env" << ENV_EOF
# KRYONIX - Vari√°veis de Ambiente
NODE_ENV=production
PORT=3000

# Keycloak
KEYCLOAK_URL=https://keycloak.$DOMAIN_BASE
KEYCLOAK_REALM=KRYONIX
KEYCLOAK_CLIENT_ID=kryonix-frontend
KEYCLOAK_CLIENT_SECRET=kryonix-frontend-secret-2025
KEYCLOAK_ADMIN_USERNAME=$KEYCLOAK_ADMIN_USER
KEYCLOAK_ADMIN_PASSWORD=$KEYCLOAK_ADMIN_PASSWORD

# Evolution API
EVOLUTION_API_URL=$EVOLUTION_API_URL
EVOLUTION_API_KEY=$EVOLUTION_API_KEY
EVOLUTION_INSTANCE=kryonix

# Database
POSTGRES_URL=postgresql://keycloak_user:$POSTGRES_PASSWORD@$POSTGRES_HOST:$POSTGRES_PORT/keycloak
POSTGRES_HOST=$POSTGRES_HOST
POSTGRES_PORT=$POSTGRES_PORT
POSTGRES_DB=keycloak
POSTGRES_USER=keycloak_user
POSTGRES_PASSWORD=$POSTGRES_PASSWORD

# Supabase (se aplic√°vel)
SUPABASE_URL=https://supabase.$DOMAIN_BASE
SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ewogICJyb2xlIjogImFub24iLAogICJpc3MiOiAic3VwYWJhc2UiLAogICJpYXQiOiAxNzE1MDUwODAwLAogICJleHAiOiAxODcyODE3MjAwCn0.hNqwb0A3qoogD8fDs7x77c0iy_VSu48TlbIpbclvvqY
SUPABASE_SERVICE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.ewogICJyb2xlIjogInNlcnZpY2Vfcm9sZSIsCiAgImlzcyI6ICJzdXBhYmFzZSIsCiAgImlhdCI6IDE3MTUwNTA4MDAsCiAgImV4cCI6IDE4NzI4MTcyMDAKfQ._UPzPrKGN1_DwLoL5u52cW-1DCeWtzGNBdLUYcTvSU0

# MinIO
MINIO_URL=https://storage.$DOMAIN_BASE
MINIO_ACCESS_KEY=kryonix
MINIO_SECRET_KEY=$POSTGRES_PASSWORD

# Redis
REDIS_URL=redis://redis-kryonix:6379
REDIS_HOST=redis-kryonix
REDIS_PORT=6379

# Alerts
ALERT_WHATSAPP=$WHATSAPP_ALERT
ALERT_EMAIL=monitoring@$DOMAIN_BASE

# JWT
JWT_SECRET=$JWT_SECRET

# Backup
BACKUP_PATH=$BACKUP_DIR
BACKUP_RETENTION_DAYS=30
ENV_EOF

        log_info "$CHECK Arquivo de vari√°veis de ambiente criado"
    else
        log_info "$CHECK Arquivo de vari√°veis de ambiente j√° existe"
    fi
}

# ============================================================================
# NOTIFICA√á√ïES
# ============================================================================

# Enviar notifica√ß√£o de WhatsApp
send_whatsapp_notification() {
    local message="$1"
    
    # Tentar enviar via Evolution API
    curl -s --max-time 10 \
        -X POST \
        -H "Content-Type: application/json" \
        -H "apikey: $EVOLUTION_API_KEY" \
        -d '{
            "number": "'${WHATSAPP_ALERT/+/}'",
            "text": "ü§ñ KRYONIX SCRIPT UNIFICADO ü§ñ\n\n'$message'\n\nServidor: '$SERVER_IP'\nTimestamp: '$(date '+%Y-%m-%d %H:%M:%S')'"
        }' \
        "$EVOLUTION_API_URL/message/sendText/main" || true
}

# ============================================================================
# ATUALIZA√á√ÉO DE PROGRESSO
# ============================================================================

# Atualizar progresso na p√°gina
update_progress_page() {
    local part_number="$1"
    local status="${2:-completed}"
    local current_date=$(date +%Y-%m-%d)

    log_info "üìä Atualizando progresso da Parte $part_number para status: $status"

    # Salvar progresso local
    echo "PART_${part_number}:${status}:${current_date}" > "$CONFIG_DIR/.progress-part-${part_number}"

    # Enviar notifica√ß√£o de progresso
    send_whatsapp_notification "‚úÖ PARTE ${part_number} CONCLU√çDA! Status atualizado para: ${status}. Data: ${current_date}. Visualizar: https://kryonix.com.br/progresso"

    log_info "$CHECK Progresso da Parte $part_number atualizado"
}

# ============================================================================
# VALIDA√á√ïES FINAIS
# ============================================================================

# Teste de conectividade dos servi√ßos
test_services_connectivity() {
    log_step "Testando conectividade dos servi√ßos"
    
    local services=(
        "https://keycloak.$DOMAIN_BASE/health/ready"
        "https://$DOMAIN_BASE/health"
        "https://api.$DOMAIN_BASE/health"
    )
    
    local failed_services=()
    
    for service in "${services[@]}"; do
        if curl -f -s --max-time 10 "$service" > /dev/null 2>&1; then
            log_info "$CHECK $service estÔøΩÔøΩ acess√≠vel"
        else
            failed_services+=("$service")
            log_warn "$WARNING $service n√£o est√° acess√≠vel"
        fi
    done
    
    if [ ${#failed_services[@]} -gt 0 ]; then
        log_warn "Alguns servi√ßos n√£o est√£o acess√≠veis ainda:"
        for service in "${failed_services[@]}"; do
            log_warn "  - $service"
        done
        log_warn "Isso pode ser normal durante a inicializa√ß√£o"
    fi
}

# Executar testes finais
run_final_tests() {
    log_step "Executando testes finais"
    
    # Fun√ßÔøΩÔøΩo para teste com timeout
    test_service() {
        local service_name="$1"
        local test_command="$2"
        local timeout_seconds="${3:-10}"
        
        if timeout "$timeout_seconds" bash -c "$test_command" >/dev/null 2>&1; then
            log_info "$CHECK $service_name funcionando"
            return 0
        else
            log_warn "$WARNING $service_name com problemas"
            return 1
        fi
    }
    
    # Testes individuais
    test_service "Keycloak" "curl -f -s $KEYCLOAK_BASE_URL/health/ready"
    test_service "Realm KRYONIX" "curl -s $KEYCLOAK_BASE_URL/realms/KRYONIX/.well-known/openid_configuration | grep -q KRYONIX"
    
    # Teste PostgreSQL baseado no tipo
    if [ "$POSTGRES_CONTAINER" = "external-supabase" ]; then
        test_service "Supabase PostgreSQL" "PGPASSWORD='$POSTGRES_PASSWORD' pg_isready -h '$POSTGRES_HOST' -U postgres"
    else
        test_service "PostgreSQL" "docker exec $POSTGRES_CONTAINER pg_isready -U postgres"
    fi

    # Teste login admin
    if test_service "Login Admin" "curl -s -d 'client_id=admin-cli' -d 'username=$KEYCLOAK_ADMIN_USER' -d 'password=$KEYCLOAK_ADMIN_PASSWORD' -d 'grant_type=password' '$KEYCLOAK_BASE_URL/realms/master/protocol/openid_connect/token' | grep -q access_token"; then
        log_info "$CHECK Autentica√ß√£o admin funcionando"
    else
        log_warn "$WARNING Autentica√ß√£o admin pode ter problemas"
    fi
    
    # Verificar scripts
    [ -x "$SCRIPTS_DIR/kryonix-create-client.sh" ] && log_info "$CHECK Scripts de automa√ß√£o instalados" || log_warn "$WARNING Scripts n√£o encontrados"
    
    # Verificar monitoramento
    systemctl is-active --quiet kryonix-monitor && log_info "$CHECK Monitoramento ativo" || log_warn "$WARNING Monitoramento n√£o est√° ativo"
    
    # Verificar cron backup
    crontab -l | grep -q "backup-kryonix.sh" && log_info "$CHECK Backup autom√°tico agendado" || log_warn "$WARNING Backup autom√°tico n√£o agendado"
}

# ============================================================================
# FUN√á√ÉO PRINCIPAL
# ============================================================================

main() {
    # Banner inicial
    echo -e "${BLUE}${BOLD}"
    echo "============================================================================"
    echo "üöÄ KRYONIX - SCRIPT PARTE 01 - FUNCIONA DE PRIMEIRA"
    echo "CONFIGURA√á√ÉO KEYCLOAK DOCKER SWARM - COMANDO TOTALMENTE CORRIGIDO"
    echo "============================================================================"
    echo -e "${NC}"

    log_info "Iniciando script PARTE 01 - Comando Keycloak FUNCIONANDO DE PRIMEIRA"
    log_info "Servidor: $SERVER_IP"
    log_info "Dom√≠nio: $DOMAIN_BASE"
    log_info "Rede: Kryonix-NET (overlay)"
    log_info "PID: $$"
    
    # Banner de in√≠cio
    echo -e "${BLUE}========================================${NC}"
    echo -e "${BLUE}üöÄ KRYONIX - PARTE 01 - COMANDO CORRIGIDO${NC}"
    echo -e "${BLUE}========================================${NC}"
    
    # Valida√ß√µes iniciais
    check_already_running
    check_root
    check_system_dependencies
    check_docker_swarm
    check_disk_space
    check_external_connectivity
    check_docker_network
    check_base_services
    
    # Configura√ß√£o do Keycloak
    create_keycloak_config
    deploy_keycloak_service
    check_existing_keycloak
    configure_keycloak_realm
    
    # Configura√ß√£o de scripts, monitoramento e backup
    setup_automation_scripts
    setup_monitoring
    setup_backup
    setup_environment
    
    # Valida√ß√µes finais
    test_services_connectivity
    run_final_tests
    
    # Marcar progresso e atualizar p√°gina
    echo "1" > "$CONFIG_DIR/.current-part"
    update_progress_page 1 "completed"
    
    # Relat√≥rio final
    log_step "Finalizando configura√ß√£o"
    log_info "$CHECK PARTE 01 configurada com sucesso!"
    log_info ""
    log_info "========================================="
    log_info "üéâ PARTE 01 CONFIGURADA COM SUCESSO!"
    log_info "========================================="
    log_info ""
    
    # Resumo final
    cat << EOF

üìã Resumo da configura√ß√£o:
   üîê Keycloak: https://keycloak.$DOMAIN_BASE
   üë§ Admin: $KEYCLOAK_ADMIN_USER / $KEYCLOAK_ADMIN_PASSWORD
   üè¢ Realm: KRYONIX
   üì± Clients: Frontend, Mobile, IA
   ü§ñ Scripts: $SCRIPTS_DIR/
   üíæ Backups: Di√°rio √†s 02:00
   üìä Monitoramento: Ativo 24/7
   ÔøΩÔøΩÔøΩÔøΩ Alertas: WhatsApp $WHATSAPP_ALERT

üõ†Ô∏è Comandos √∫teis:
   ‚Ä¢ Criar cliente: $SCRIPTS_DIR/kryonix-create-client.sh
   ‚Ä¢ Validar clientes: $SCRIPTS_DIR/kryonix-validate-clients.sh
   ‚Ä¢ Backup manual: $SCRIPTS_DIR/backup-kryonix.sh
   ‚Ä¢ Ver logs monitor: tail -f $LOG_DIR/monitor.log
   ‚Ä¢ Status monitor: systemctl status kryonix-monitor

EOF
    
    # Enviar notifica√ß√£o de sucesso
    send_whatsapp_notification "‚úÖ KRYONIX PARTE-01 CONCLU√çDA! Keycloak multi-tenant funcionando, IA integrada, interface portugu√™s, WhatsApp OTP ativo, monitor 24/7, backup autom√°tico, multi-tenancy operacional. Pronto para PARTE-02!"
    
    # SEMPRE MOSTRAR CREDENCIAIS NO FINAL
    log_info ""
    log_info "üîë ===== CREDENCIAIS KRYONIX COMPLETAS ====="
    log_info ""
    log_info "üåê KEYCLOAK:"
    log_info "   URL Admin: https://keycloak.$DOMAIN_BASE/admin"
    log_info "   URL Public: https://keycloak.$DOMAIN_BASE"
    log_info "   UsuÔøΩÔøΩrio: $KEYCLOAK_ADMIN_USER"
    log_info "   Senha: $KEYCLOAK_ADMIN_PASSWORD"
    log_info "   Realm: KRYONIX"
    log_info ""
    log_info "üóÑÔ∏è DATABASE KEYCLOAK:"
    log_info "   Host: $POSTGRES_HOST"
    log_info "   Porta: $POSTGRES_PORT"
    log_info "   Database: keycloak"
    log_info "   Usu√°rio: keycloak_user"
    log_info "   Senha: $POSTGRES_PASSWORD"
    log_info ""
    log_info "üîê CLIENTS CONFIGURADOS:"
    log_info "   Frontend Client ID: kryonix-frontend"
    log_info "   Frontend Secret: kryonix-frontend-secret-2025"
    log_info "   Mobile Client ID: kryonix-mobile-app"
    log_info "   Mobile Secret: kryonix-mobile-secret-2025"
    log_info "   IA Client ID: kryonix-ai-client"
    log_info "   IA Secret: kryonix-ai-secret-2025"
    log_info ""
    log_info "üì± EVOLUTION API:"
    log_info "   URL: $EVOLUTION_API_URL"
    log_info "   API Key: $EVOLUTION_API_KEY"
    log_info "   WhatsApp: $WHATSAPP_ALERT"
    log_info ""
    log_info "üîß SENDGRID EMAIL:"
    log_info "   API Key: $SENDGRID_API_KEY"
    log_info "   Email Admin: $ADMIN_EMAIL"
    log_info ""
    log_info "üîí JWT SECRET:"
    log_info "   Secret: $JWT_SECRET"
    log_info ""
    log_info "üõ†Ô∏è ARQUIVOS IMPORTANTES:"
    log_info "   Logs: $LOG_DIR/"
    log_info "   Configs: $CONFIG_DIR/"
    log_info "   Scripts: $SCRIPTS_DIR/"
    log_info "   Backups: $BACKUP_DIR/"
    log_info ""
    log_info "üéØ ===== FIM DAS CREDENCIAIS ====="
    log_info ""
    
    # VERIFICAR SE TODOS OS SERVI√áOS FORAM CRIADOS
    log_info "üîç VERIFICA√á√ÉO FINAL DOS SERVI√áOS CRIADOS:"
    log_info ""
    
    # Verificar Keycloak
    if docker service ls --format "{{.Name}}" | grep -q "keycloak"; then
        log_info "‚úÖ Keycloak: Servi√ßo Docker Swarm criado"
    else
        log_warn "‚ö†Ô∏è Keycloak: Servi√ßo Docker Swarm N√ÉO encontrado"
    fi
    
    # Verificar Monitoramento
    if systemctl is-active --quiet kryonix-monitor; then
        log_info "‚úÖ Monitoramento: Servi√ßo systemd ativo"
    else
        log_warn "‚ö†Ô∏è Monitoramento: Servi√ßo systemd N√ÉO ativo"
    fi
    
    # Verificar Backup
    if crontab -l | grep -q "backup-kryonix.sh"; then
        log_info "‚úÖ Backup: Cron job agendado"
    else
        log_warn "‚ö†Ô∏è Backup: Cron job N√ÉO agendado"
    fi
    
    # Verificar Scripts
    if [ -f "$SCRIPTS_DIR/kryonix-create-client.sh" ]; then
        log_info "‚úÖ Scripts: Cria√ß√£o de cliente dispon√≠vel"
    else
        log_warn "‚ö†Ô∏è Scripts: Script de cria√ß√£o N√ÉO encontrado"
    fi
    
    log_info ""
    log_info "üõ†Ô∏è COMANDOS PARA COMPLETAR A CONFIGURA√á√ÉO (se necess√°rio):"
    log_info ""
    log_info "   # Se Keycloak n√£o estiver funcionando:"
    log_info "   bash \"Scripts-de-instalacoes/fix-keycloak-complete.sh\""
    log_info ""
    log_info "   # Para configurar Realm e Clients:"
    log_info "   bash \"Scripts-de-instalacoes/complete-keycloak-setup.sh\""
    log_info ""
    log_info "   # Para verificar servi√ßos:"
    log_info "   docker service ls"
    log_info "   systemctl status kryonix-monitor"
    log_info "   crontab -l"
    log_info ""
    
    log_info "ÔøΩÔøΩÔøΩÔøΩ Sistema pronto para receber a PARTE-02!"
    log_info "Script executado com sucesso em $(date)"
}

# ============================================================================
# EXECU√á√ÉO DO SCRIPT
# ============================================================================

# Executar fun√ß√£o principal
main "$@"

# Fim do script
exit 0
